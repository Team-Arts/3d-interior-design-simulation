#include "MainApp.h"
#include "../Graphics/Renderer.h"
#include "../Graphics/Mesh.h"
#include "../Graphics/Shader.h"
#include "../Scene/InteriorObject.h"
#include "../Components/MeshRenderer.h"
#include "../Components/Transform.h"
#include "../UI/UIManager.h"
#include "../Graphics/ModelLoader.h"
#include "../Character/Character.h"
#include "../Input/InputManager.h"

#include <memory>
#include <iostream>

namespace visualnnz
{
using namespace std;
using namespace DirectX::SimpleMath;

MainApp::MainApp()
{
    m_renderer = make_unique<Renderer>();
    m_testCube = nullptr;
    m_cubeMesh = nullptr;
    m_basicShader = nullptr;
    
    cout << "MainApp constructor completed" << endl;
}

MainApp::~MainApp() = default;

bool MainApp::Initialize(HINSTANCE hInstance, int nCmdShow)
{
    cout << "MainApp::Initialize starting..." << endl;
    
    // 부모 클래스 초기화 (윈도우 생성)
    if (!AppBase::Initialize(hInstance, nCmdShow))
    {
        cout << "Failed to initialize AppBase!" << endl;
        return false;
    }

    // 그래픽스 초기화
    if (!InitializeGraphics())
    {
        cout << "Failed to initialize graphics!" << endl;
        return false;
    }

    // 매니저들 초기화
    InitializeManagers();

    // UI 콜백 설정
    SetupUICallbacks();

    // 테스트 오브젝트들 생성
    CreateTestObjects();
    
    cout << "MainApp initialized successfully!" << endl;
    return true;
}

bool MainApp::InitializeGraphics()
{
    cout << "Initializing graphics..." << endl;
    
    // 렌더러 초기화(Direct3D 관련 설정)
    if (!m_renderer->Initialize(m_mainWindow))
    {
        cout << "Failed to initialize renderer!" << endl;
        return false;
    }
    
    cout << "Graphics initialized successfully!" << endl;
    return true;
}

void MainApp::InitializeManagers()
{
    cout << "MainApp::InitializeManagers starting..." << endl;
    
    // 부모 클래스의 매니저 초기화 먼저 호출
    AppBase::InitializeManagers();

    // UIManager 초기화 (디바이스가 필요함)
    if (!m_uiManager->Initialize(m_mainWindow, m_renderer->GetDevice(), m_renderer->GetDeviceContext()))
    {
        cout << "Failed to initialize UIManager!" << endl;
        return;
    }

    // InputManager에 캐릭터 연결 (캐릭터 생성 후에 업데이트됨)
    if (m_inputManager && m_character)
    {
        m_inputManager->SetCharacter(m_character);
    }

    cout << "MainApp managers initialized successfully!" << endl;
}

void MainApp::CreateTestObjects()
{
    cout << "Creating test objects..." << endl;
    
    // 1. 기본 셰이더 생성
    m_basicShader = make_shared<Shader>();
    wstring vsPath = L"src/Graphics/shaders/BasicVertexShader.hlsl";
    wstring psPath = L"src/Graphics/shaders/BasicPixelShader.hlsl";
    
    if (!m_basicShader->Initialize(m_renderer->GetDevice(), vsPath, psPath))
    {
        cout << "Failed to create basic shader!" << endl;
        return;
    }

    // 2. 큐브 메시 생성
    m_cubeMesh = make_shared<Mesh>();
    auto vertices = Mesh::CreateCubeVertices();
    auto indices = Mesh::CreateCubeIndices();
    
    if (!m_cubeMesh->Initialize(m_renderer->GetDevice(), vertices, indices))
    {
        cout << "Failed to create cube mesh!" << endl;
        return;
    }

    // 3. 테스트 큐브 오브젝트 생성
    m_testCube = make_unique<InteriorObject>();
    
    if (m_testCube->Initialize(m_renderer->GetDevice(), "TestCube", "cube"))
    {
        // MeshRenderer에 메시와 셰이더 설정
        m_testCube->GetMeshRenderer()->SetMesh(m_cubeMesh);
        m_testCube->GetMeshRenderer()->SetShader(m_basicShader);
        
        // Transform 설정
        m_testCube->GetTransform()->SetPosition(Vector3(0.0f, 0.0f, 0.0f));
        m_testCube->GetTransform()->SetScale(Vector3(1.0f, 1.0f, 1.0f));
        
        // 씬 오브젝트 배열에 추가 (AppBase의 m_sceneObjects 배열)
        auto sharedCube = shared_ptr<InteriorObject>(m_testCube.get(), [](InteriorObject*){});
        m_sceneObjects.push_back(sharedCube);
        
        cout << "Test cube created successfully!" << endl;
    }
    else
    {
        cout << "Failed to initialize test cube!" << endl;
    }
}

shared_ptr<InteriorObject> MainApp::CreateTestObject(const string& objectId, const string& objectType, const Vector3& position)
{
    auto newObject = make_shared<InteriorObject>();
    
    if (newObject->Initialize(m_renderer->GetDevice(), objectId, objectType))
    {
        // 기본 메시와 셰이더 설정
        newObject->GetMeshRenderer()->SetMesh(m_cubeMesh);
        newObject->GetMeshRenderer()->SetShader(m_basicShader);
        
        // 위치 설정
        newObject->GetTransform()->SetPosition(position);
        newObject->GetTransform()->SetScale(Vector3(1.0f, 1.0f, 1.0f));
        
        return newObject;
    }
    
    return nullptr;
}

void MainApp::Update(float deltaTime)
{
    // AppBase에서 이미 씬 오브젝트 업데이트와 UI 업데이트를 처리하므로
    // MainApp에서는 추가적인 로직만 구현
    
    // 큐브 회전 애니메이션 (선택되지 않았을 때만)
    if (m_testCube && !m_testCube->IsSelected())
    {
        static float rotation = 0.0f;
        rotation += deltaTime * 0.5f; // 천천히 회전
        m_testCube->GetTransform()->SetRotation(Vector3(0.0f, rotation, 0.0f));
    }
}

void MainApp::Render()
{
    // 3D 씬 렌더링
    float clearColor[4] = {0.2f, 0.2f, 0.2f, 1.0f};
    m_renderer->BeginScene(clearColor);

    // 씬 오브젝트들 렌더링 (AppBase의 m_sceneObjects 배열)
    for (auto& obj : m_sceneObjects)
    {
        if (obj)
        {
            m_renderer->Draw(obj.get());
        }
    }

    // 캐릭터 렌더링
    if (m_character)
    {
        m_character->Render(m_renderer->GetDeviceContext(), *m_camera);
    }

    m_renderer->EndScene();

    // UI 렌더링
    if (m_uiManager)
    {
        m_uiManager->BeginFrame();
        m_uiManager->Render();
        m_uiManager->EndFrame();
    }
}

void MainApp::OnModelSpawn(const string& modelName)
{
    cout << "MainApp::OnModelSpawn - " << modelName << endl;
    
    string filePath = "asset/models/" + modelName;
    string objectID = "Model_" + to_string(m_sceneObjects.size());
    
    // GLB 파일 로드 시도
    auto newObject = m_modelLoader->LoadModel(m_renderer->GetDevice(), filePath, objectID);
    if (newObject)
    {
        // 기본 셰이더 설정
        newObject->GetMeshRenderer()->SetShader(m_basicShader);
        
        // 기본 위치 설정 (기존 오브젝트들과 위치가 겹치지 않도록)
        float offsetX = (m_sceneObjects.size() % 3) * 2.0f - 2.0f;
        float offsetZ = (m_sceneObjects.size() / 3) * 2.0f;
        newObject->GetTransform()->SetPosition(Vector3(offsetX, 0.0f, offsetZ));
        
        m_sceneObjects.push_back(newObject);
        cout << "Model loaded successfully: " << modelName << endl;
    }
    else
    {
        cout << "Failed to load model: " << modelName << " - Creating test cube instead" << endl;
        
        // 대신 테스트 큐브 생성
        float offsetX = (m_sceneObjects.size() % 3) * 2.0f - 2.0f;
        float offsetZ = (m_sceneObjects.size() / 3) * 2.0f;
        Vector3 position(offsetX, 0.0f, offsetZ);
        
        auto testObject = CreateTestObject(objectID, "test_cube", position);
        if (testObject)
        {
            m_sceneObjects.push_back(testObject);
            cout << "Created test cube instead: " << objectID << endl;
        }
    }
}

void MainApp::OnCharacterSpawn(const string& characterName)
{
    cout << "MainApp::OnCharacterSpawn - " << characterName << endl;
    
    // 캐릭터가 이미 존재하면 새로 생성하지 않음
    if (m_character)
    {
        cout << "Character already exists!" << endl;
        return;
    }

    // 새 캐릭터 생성
    m_character = make_shared<Character>();
    
    // 캐릭터 초기화 (실제 디바이스와 함께)
    if (m_character->Initialize(m_renderer->GetDevice(), ""))
    {
        cout << "Character created successfully!" << endl;
        
        // 캐릭터를 씬 중앙에 배치
        m_character->SetPosition(Vector3(0.0f, 0.1f, 3.0f));
        
        // InputManager에 캐릭터 연결
        if (m_inputManager)
        {
            m_inputManager->SetCharacter(m_character);
            m_inputManager->SetInputMode(InputMode::Character);
            cout << "Character control mode activated" << endl;
        }
        
        // UI에 캐릭터 연결
        if (m_uiManager)
        {
            m_uiManager->SetCharacter(m_character);
        }
    }
    else
    {
        cout << "Failed to create character!" << endl;
        m_character = nullptr;
    }
}

} // namespace visualnnz